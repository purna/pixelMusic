{
  "schemaVersion": "1.0.0",
  "name": "Strudel Pattern Language Schema Collection",
  "description": "Complete schema definition for Strudel live coding music environment",
  
  "schemas": {
    "nodeSchema": {
      "file": "strudel-node-schema.json",
      "version": "2.0",
      "description": "Node types, sockets, execution stages, and signal flow",
      "covers": [
        "Node definitions (Instrument, Drum, Stack, etc.)",
        "Socket types and compatibility",
        "Execution stages and priorities",
        "Validation rules for node graphs"
      ]
    },
    
    "nodeProperties": {
      "file": "strudel-node-properties.json",
      "version": "1.0.0",
      "description": "UI controls and property mappings for nodes",
      "covers": [
        "Property definitions for each node type",
        "UI control types (knobs, sliders, selects)",
        "Parameter ranges and defaults",
        "Mapping to Strudel API"
      ]
    },
    
    "nodeInstruments": {
      "file": "strudel-node-instruments.json",
      "version": "1.0",
      "description": "Instrument library and menu organization",
      "covers": [
        "Instrument categories (drums, percussion, mallet, etc.)",
        "Sound sample names",
        "Menu structure for UI",
        "Pattern and effect groupings"
      ]
    },
    
    "controlNodes": {
      "file": "strudel-control-nodes.json",
      "version": "1.0.0",
      "description": "Control signal generators (LFOs, randoms, patterns)",
      "covers": [
        "LFO types (sine, saw, square)",
        "Random generators (rand, irand)",
        "Pattern generators",
        "Control signal routing"
      ]
    },
    
    "miniNotation": {
      "file": "strudel-mini-notation.json",
      "version": "1.0.0",
      "description": "Mini-notation syntax - DSL for pattern strings",
      "covers": [
        "Syntax operators (~, _, [ ], < >, *, /, !, @, etc.)",
        "Operator precedence and parsing rules",
        "Pattern types (sound, note, number, chord)",
        "Nesting and escaping rules",
        "Validation patterns"
      ]
    },
    
    "patternCombinators": {
      "file": "strudel-pattern-combinators.json",
      "version": "1.0.0",
      "description": "Higher-order pattern composition functions",
      "covers": [
        "Structural combinators (stack, cat, seq)",
        "Rhythmic functions (struct, mask, euclidean)",
        "Temporal transforms (off, slow, fast)",
        "Conditional functions (every, whenmod, sometimes)"
      ]
    },
    
    "patternFunctions": {
      "file": "strudel-pattern-functions.json",
      "version": "1.0.0",
      "description": "Pattern constructor functions and chainable methods",
      "covers": [
        "Constructor functions (s, n, note, chord, scale)",
        "Chainable methods (bank, room, gain, pan, speed)",
        "Effect methods (lpf, hpf, delay, reverb)",
        "Mini-notation support in method arguments"
      ]
    }
  },
  
  "coverage": {
    "yourExample": "stack(s('bd').struct('<[x*<1 2> [~@3 x]] x>'), s('~ [rim, sd:<2 3>]').room('<0 .2>'), n('[0 <1 3>]*<2!3 4>').s('hh')).bank('tr909')",
    "breakdown": {
      "stack": {
        "covered": true,
        "schema": "patternCombinators",
        "details": "Structural combinator that layers patterns in parallel"
      },
      "s": {
        "covered": true,
        "schema": "patternFunctions",
        "details": "Sound pattern constructor function"
      },
      "struct": {
        "covered": true,
        "schema": "patternCombinators",
        "details": "Rhythmic structure application method"
      },
      "miniNotation": {
        "covered": true,
        "schema": "miniNotation",
        "elements": [
          "'<[x*<1 2> [~@3 x]] x>' - alternation, grouping, multiply, elongate",
          "'~ [rim, sd:<2 3>]' - rest, grouping, parallel, nested alternation",
          "'[0 <1 3>]*<2!3 4>' - grouping, alternation, multiply, replicate"
        ]
      },
      "room": {
        "covered": true,
        "schema": "patternFunctions",
        "details": "Reverb room size method, accepts mini-notation"
      },
      "n": {
        "covered": true,
        "schema": "patternFunctions",
        "details": "Number/note pattern constructor"
      },
      "bank": {
        "covered": true,
        "schema": "patternFunctions",
        "details": "Drum bank selection method"
      }
    },
    "childNodeArchitecture": {
      "covered": true,
      "schema": "nodeSchema",
      "details": "Complete parent-child relationship system implemented",
      "elements": [
        "Container nodes (Stack, Sequence, Group) with childSlot support",
        "Wrapper nodes (Often, Sometimes, Rarely) with transform child support",
        "Transform nodes (Jux, Rev, Palindrome) with pattern child support",
        "Execution context hierarchy for nested evaluation",
        "Socket compatibility matrix for child connections"
      ]
    },
    "missingElementsAdded": {
      "covered": true,
      "schema": "all",
      "details": "All previously missing elements now implemented",
      "elements": [
        "Effects: Gain, Crush, Shape, Vowel filters",
        "Transforms: Jux, Rev, Palindrome, Shuffle, Scramble, Ply",
        "Controls: Perlin noise, Step sequencer, Sample & Hold",
        "Instruments: Synthesizers, Bass, Vocals, World instruments",
        "Methods: accelerate, decelerate, segment, chunk, fit, scale, chord, arp"
      ]
    }
  },
  
  "languageLayers": {
    "layer1_nodeGraph": {
      "description": "Visual node-based composition",
      "schemas": ["nodeSchema", "nodeProperties", "nodeInstruments", "controlNodes"],
      "userInterface": "Drag-and-drop nodes with visual connections"
    },
    
    "layer2_miniNotation": {
      "description": "Compact pattern strings (TidalCycles-inspired)",
      "schemas": ["miniNotation"],
      "userInterface": "Text strings within s(), n(), note() functions"
    },
    
    "layer3_combinators": {
      "description": "Functional pattern composition",
      "schemas": ["patternCombinators", "patternFunctions"],
      "userInterface": "JavaScript function calls and method chaining"
    }
  },
  
  "usagePatterns": {
    "simplePattern": {
      "example": "s('bd sd hh oh')",
      "schemas": ["patternFunctions", "miniNotation"]
    },
    
    "withEffects": {
      "example": "s('bd sd').room(0.5).gain(0.8)",
      "schemas": ["patternFunctions"]
    },
    
    "structured": {
      "example": "s('bd').struct('x ~ x ~')",
      "schemas": ["patternFunctions", "patternCombinators", "miniNotation"]
    },
    
    "parallel": {
      "example": "stack(s('bd'), s('hh*4'))",
      "schemas": ["patternCombinators", "patternFunctions", "miniNotation"]
    },
    
    "complex": {
      "example": "stack(s('bd').struct('<[x*<1 2> [~@3 x]] x>'), s('~ [rim, sd:<2 3>]').room('<0 .2>'), n('[0 <1 3>]*<2!3 4>').s('hh')).bank('tr909')",
      "schemas": ["all"],
      "description": "Full language features: combinators, mini-notation, effects, chaining"
    }
  },
  
  "implementationGuidance": {
    "parsing": {
      "order": [
        "1. Parse mini-notation strings into AST",
        "2. Resolve pattern constructors (s, n, note, etc.)",
        "3. Apply combinators (stack, cat, etc.)",
        "4. Chain methods (struct, room, bank, etc.)",
        "5. Build execution graph by stage priority",
        "6. Resolve parent-child relationships",
        "7. Validate socket compatibility"
      ]
    },
    
    "execution": {
      "stageOrder": [
        "source (10) - Sound generators",
        "structural (20) - Pattern combinators",
        "rhythmic (30) - Time/rhythm transforms",
        "pitch (40) - Pitch modulation",
        "modulation (50) - LFOs and control",
        "spectral (60) - Filters and spectral effects",
        "space (70) - Spatial effects (reverb, delay, pan)",
        "wrapper (80) - Conditional/probabilistic"
      ],
      "childContextHierarchy": [
        "1. Parent nodes execute first in their stage",
        "2. Child patterns inherit parent execution context",
        "3. Wrapper nodes create conditional execution contexts",
        "4. Transform nodes modify child patterns within context",
        "5. Execution flows from root to leaves, then combines results"
      ]
    },
    
    "validation": {
      "checks": [
        "Balanced brackets in mini-notation",
        "Valid socket connections in node graph",
        "Stage ordering in execution chain",
        "Parameter ranges",
        "Required properties present",
        "Child node compatibility with parent types",
        "Execution context hierarchy integrity"
      ]
    },
    "childNodePatterns": {
      "containerUsage": [
        "Stack with child patterns: stack(s('bd'), s('hh')).child(s('sd'))",
        "Group with child patterns: group(s('bd'), s('sd')).child(s('hh'))",
        "Sequence with child patterns: seq(s('bd'), s('sd')).child(s('hh'))"
      ],
      "wrapperUsage": [
        "Often with transform: often(0.7).child(x => x.speed(2))",
        "Sometimes with multiple transforms: sometimes(0.5).child([x => x.pan(-1), x => x.pan(1)])",
        "Rarely with complex transform: rarely(0.25).child(x => x.struct('x ~ x ~'))"
      ],
      "transformUsage": [
        "Jux with stereo transforms: jux(x => x, x => x.pan(1))",
        "Rev with pattern child: rev().child(s('bd sd hh oh'))",
        "Palindrome with pattern child: palindrome().child(n('0 1 2 3'))"
      ]
    }
  },
  
  "additionalNotes": {
    "miniNotationContext": "Mini-notation can appear in string arguments to pattern functions AND in method arguments that accept patterns (like room('<0 .2>'))",
    
    "methodChaining": "Most pattern methods return a Pattern, allowing unlimited chaining: s('bd').struct('x ~').room(0.5).gain(0.8).bank('tr909')",
    
    "patternAsArgument": "Many methods accept patterns as arguments, not just constants: .room('<0 .2>') alternates room size",
    
    "nodeVsCode": "Node graphs are one way to compose; the same functionality exists in code via combinators and methods"
  }
}